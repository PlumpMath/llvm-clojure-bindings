

* What is this?
This is a compiler. When you run it, it compiles 'input.program' and produces a binary a.out.

The frontend is written in clojure, and the back-end is LLVM.

* How to Run
1) Install LLVM library.
2) lein deps
3) lein run

NOTE: The code assumes LLVM is at /opt/local/lib/libLLVM-2.9.dylib For different paths, update jna.library.path java property in native.clj.

* Input Program 
Here our toy language is used as input into compiler frontend.
#+BEGIN_SRC c
func cos(Double) Double;
func printf(...) Integer;

func bar() Integer {
   printf("foo");
   return 3;
}

func main() Integer {
    printf("hello %d", 3);
    printf("bar ");
    bar();
    return 0;
}
#+END_SRC

* Program Output

1) The intermediate representation is printed.
2) The object file and linked binary is created.
3) Binary is executed, output is shown at bottom.

[[https://github.com/jasonjckn/llvm-clojure-bindings/raw/master/pic.png]]


* How does it work?
+ parser.clj uses a combinator parser and constructs IR#1
+ llvm.clj contains needed llvm bindings for clojure.
+ native.clj is like clj-native, but less efficient. (I couldn't get arrays of pointers working in clj-native.)
+ parser.clj is for transforming Input=>IR#1
+ ast.clj is for transforming IR#1=>IR#2
+ main.clj is for IR#2=>object file=>linking.

If input program is this:
#+BEGIN_SRC
func main() Integer {
    printf("hello");
    printf("bar ");
    return 1;
}
#+END_SRC

IR#1 looks like this:
#+BEGIN_SRC
  ((:func main [] Integer
          (:call printf "foo")
          (:call printf "hello")
          (:return 1)))
#+END_SRC

IR#2 looks like this (LLVM IR):
#+BEGIN_SRC
@0 = internal constant [4 x i8] c"foo\00"
@1 = internal constant [9 x i8] c"hello %d\00"

define i32 @main() {
  %1 = call i32 (...)* @printf([9 x i8]* @1, i32 3)
  %2 = call i32 (...)* @printf([5 x i8]* @2)
  ret i32 1
}
#+END_SRC

